---
title: "Statistical Methods in Finance Final Project"
date: "May 09, 2022"
output: "pdf_document"
---

This document is for calculation purposes only and does not represent the final analysis.
```{r, echo = F, eval = F}
rm(list = ls())
```
### Data Processing
```{r, warning=FALSE, message=FALSE}
require(tidyverse)
require(tidyquant)
require(xts)
require(lubridate)
require(tsibble) # Time series tibble

require(MASS) # for fitdistr() and kde2d() functions
require(copula) # for copula functions
require(fGarch) # for standardized t density
require(e1071)
require(nortest)
require(tseries)

require(ggplot2)
require(ggpubr)
require(GGally)
require(png)

theme_set(theme_bw())
```

```{r}
FILENAME = "./data/portfolio_historical_data.csv"
IMG_PATH = "./images/"
DOWNLOAD.DATA = !file.exists(FILENAME)

# Asset symbols that will be used for this analysis
STOCK.SYMBOLS = c(
    "AMD", "MSFT", "SBUX", "AAPL",
    "ITUB", "FB", "NVDA", "F",
    "BAC", "T", "XOM", "VALE"
)
ASSET.NAMES = c(
    "AMD", "Microsoft", "Starbux", "Apple Inc",
    "Itau Unibanco Holding S.A.", "Meta Platforms Inc", "NVIDIA", "Ford",
    "Bank Of America Corp.", "AT&T Inc.", "Exxon Mobil Corp.", "Vale S.A.",
    "S&P 500"
)
SP500.SYMBOL = "GSPC"

YEARS = 5
to.date = lubridate::date("2021-11-1")
from.date = to.date - years(YEARS) - months(1)
dates = seq(from.date, to.date - months(1), by = "months")

risk.free = 0.03
```
```{r}
if(DOWNLOAD.DATA) {
    # Download the assets' hisotrical data and load the
    # variables to the environment
    getSymbols(
        Symbols = c(STOCK.SYMBOLS, paste0("^", SP500.SYMBOL)),
        src = "yahoo",
        from = from.date,
        to = to.date,
        periodicity = "monthly"
    ) %>% suppressMessages()

    historical.data = cbind(
        AMD, MSFT, SBUX, AAPL,
        ITUB, FB, NVDA, F,
        BAC, T, XOM, VALE, GSPC
    )

    # Save the net returns into a csv file
    write.zoo(
        historical.data, FILENAME,
         index.name = "Date", sep = ","
    )
} else {
    historical.data = read.csv.zoo(FILENAME, header = T) %>%
                        xts()
}

adj.columns = endsWith(colnames(historical.data), "Adjusted")
adj.price = historical.data[-1, adj.columns]

colnames(adj.price) = gsub(".Adjusted", "", colnames(adj.price))

# Calcualte the net returns for each asset
# (note: ugly, but gets the work done)
net.returns = cbind(
    CalculateReturns(adj.price[, 1 ], method = "simple"),
    CalculateReturns(adj.price[, 2 ], method = "simple"),
    CalculateReturns(adj.price[, 3 ], method = "simple"),
    CalculateReturns(adj.price[, 4 ], method = "simple"),
    CalculateReturns(adj.price[, 5 ], method = "simple"),
    CalculateReturns(adj.price[, 6 ], method = "simple"),
    CalculateReturns(adj.price[, 7 ], method = "simple"),
    CalculateReturns(adj.price[, 8 ], method = "simple"),
    CalculateReturns(adj.price[, 9 ], method = "simple"),
    CalculateReturns(adj.price[, 10], method = "simple"),
    CalculateReturns(adj.price[, 11], method = "simple"),
    CalculateReturns(adj.price[, 12], method = "simple"),
    CalculateReturns(adj.price[, 13], method = "simple")
)[-1]

sp500.adj = adj.price$GSPC
sp500.returns = net.returns$GSPC

# Remove S&P500 from the adjusted price and net returns data frames
adj.price$GSPC = NULL
net.returns$GSPC = NULL

```
```{r, eval = F, echo = F}
head(historical.data)[, 1:5]
head(adj.price)[, 1:5]
head(net.returns)[, 1:5]
```

## Summary

## Descriptive Statistics

### Sample Statistics
```{r}
returns.summary = summary(net.returns)

# Means
m = colMeans(net.returns)
m

# Standard Deviations
cov.mat = cov(net.returns)
std.dev = diag(cov.mat) %>% sqrt()
std.dev

# Skewness Coefficients
skewness.coeff = skewness(net.returns)
skewness.coeff

# Kurtosis Coefficients
kurtosis.coeff = kurtosis(net.returns) + 3
kurtosis.coeff
```
```{r, echo = F}
# This is a helper function to create plots on a n x m grid given the passed dataset
create.line.plots = function(data, plot.type, x.lab = "x", y.lab = "y", nrow = 4, ncol = 3) {
    n = dim(data)[1]; p = dim(data)[2]
    

    plots = list()
    plot.data = as_tibble(data)
    plot.data$Date = dates[-1:-(length(dates) - n)]

    i = 1
    for (asset in colnames(plot.data)[1:p]) {
        plots[[i]] = plot.data %>% 
                        ggplot(aes(x = Date, y = .data[[asset]])) +
                            plot.type() +
                            scale_x_date() +
                            labs(
                                title = colnames(plot.data)[i],
                                x = x.lab,
                                y = y.lab
                            )
        i = i + 1
    }
    if(p > 1) {
        return(ggarrange(plotlist = plots, nrow = nrow, ncol = ncol))
    }
    return(plots[1])
}

create.histogram = function(data, x.lab = "x", y.lab = "y", nrow = 4, ncol = 3) {
    n = dim(data)[1]; p = dim(data)[2]

    plots = list()
    plot.data = as_tibble(data)

    i = 1
    for (asset in colnames(plot.data)[1:p]) {
        plots[[i]] = plot.data %>% 
                        ggplot(aes(x = .data[[asset]])) +
                            geom_histogram() +
                            labs(
                                title = ASSET.NAMES[i],
                                x = x.lab,
                                y = y.lab
                            )
        i = i + 1
    }
    if(p > 1) {
        return(
            ggarrange(plotlist = plots, nrow = nrow, ncol = ncol) %>%
                suppressMessages()
        )
    }
    return(plots[1] %>% suppressMessages())
}

create.boxplot = function(data, x.lab = "x", y.lab = "y", nrow = 4, ncol = 3) {
    n = dim(data)[1]; p = dim(data)[2]

    plots = list()
    plot.data = as_tibble(data)
    plot.data$Date = dates[-1:-(length(dates) - n)]

    i = 1
    for (asset in colnames(plot.data)[1:p]) {
        plots[[i]] = plot.data %>% 
                        ggplot(aes(y = .data[[asset]])) +
                            geom_boxplot()+
                            labs(
                                title = ASSET.NAMES[i],
                                x = x.lab,
                                y = y.lab
                            )
        i = i + 1
    }
    if(p > 1) {
        return(
            ggarrange(plotlist = plots, nrow = nrow, ncol = ncol) %>%
                suppressMessages()
        )
    }
    return(plots[1] %>% suppressMessages())
}

create.qq.plots = function(data, y.lab = "y", nrow = 4, ncol = 3) {
    n = dim(data)[1]; p = dim(data)[2]

    plots = list()
    plot.data = as_tibble(data)

    i = 1
    for (asset in colnames(plot.data)[1:p]) {
        plots[[i]] = plot.data %>% 
                        ggplot(aes(sample = .data[[asset]])) +
                            stat_qq() +
                            stat_qq_line(color = "red") +
                            labs(
                                title = paste(
                                    ASSET.NAMES[i],
                                    "Normal Q-Q Plot"
                                ),
                                x = "Normal Distribution",
                                y = y.lab
                            ) 
        i = i + 1
    }
    if(p > 1) {
        return(
            ggarrange(plotlist = plots, nrow = nrow, ncol = ncol) %>%
                suppressMessages()
        )
    }
    return(plots[1] %>% suppressMessages())
}

create.equity.curve = function(data, x.lab = x, y.lab = "y") {
    n = dim(data)[1]; p = dim(data)[2]
    dollar.growth = rep(list(rep(1, n + 1)), p)

    for(j in 1:p) {
        s = 1
        m = net.returns[, j] %>% as.numeric()
        for(i in seq.int(1, n)) {
            gr = 1 + m[i]                # gross return
            s = s * gr
            dollar.growth[[j]][i + 1] = s
        }
    }

    names(dollar.growth) = colnames(data)
    dollar.growth = dollar.growth %>% as_tibble()
    create.line.plots(
        dollar.growth, geom_line,
        x.lab = x.lab,
        y.lab = y.lab, nrow = 4, ncol = 3
    )
}
```
### Monthly prices and returns plot
```{r, fig.align="center", fig.width = 12, fig.height=10}
# Yearly Adjusted Price plot
create.line.plots(adj.price, geom_line, x.lab = "Year", y.lab = "Adj. Price")

# Yearly Net Returns plot
create.line.plots(net.returns, geom_area, x.lab = "Year", y.lab = "Net Returns")
# TODO: Check for anormalities
```
```{r, fig.align="center", fig.width = 12, fig.height=10}
create.equity.curve(net.returns, x.lab = "Year", y.lab = "Growth of $1")
create.equity.curve(sp500.returns, x.lab = "Year", y.lab = "Growth of $1")
```
```{r, fig.align="center", fig.width = 12, fig.height=10}
# Yearly Net Returns plot
create.histogram(net.returns,  x.lab = "Net Returns")
create.boxplot(net.returns, y.lab = "Net Returns")
create.qq.plots(net.returns, y.lab = "Net Returns")
# TODO: Check for anormalities
```


### Stationarity test
```{r}
apply(net.returns, 2, adf.test) %>% suppressWarnings()
```
Starbucks and NVIDIA are non-stationary. The rest is stationary

### Normally distributed
```{r}
apply(net.returns, 2, lillie.test)
```
The P-values are all greater than 0.05, hence we don't have
any evidence suggesting that the returns are normally distributed
### Outliers
```{r}
summary(net.returns)
```
The boxplots above suggest the presence of outliers in the dataset. This claim
is further backed by the summary table above.

### Which distribution fits best
```{r}
measure_fitness = function(y, fun, ...) {
    fit = fun(y, ...) %>% suppressWarnings()
    if ("minimum" %in% names(fit)){
        nll = fit$minimum
        p = 3
    } else {
        nll = fit$objective
        p = length(fit$par)
    }
    n = length(y)
    aic = 2 * nll + 2 * p
    bic = 2 * nll - nll * p

    return(c(aic, bic))
}

distributions = c("Standardized t", "Skewed t", "GED", "Skewed GED")
best_fit = function(return) {
    print(paste("Testing:", colnames(return)))
    fitness = data.frame(list(
        std_t = measure_fitness(return, stdFit),
        skewed_std_t = measure_fitness(return, sstdFit),
        ged = measure_fitness(return, gedFit),
        skewed_ged = measure_fitness(return, sgedFit)
    ))
    colnames(fitness) = distributions
    row.names(fitness) = c("AIC", "BIC")

    fitness
}

best_fit(net.returns[, 1 ]) # Standardized t
best_fit(net.returns[, 2 ])
best_fit(net.returns[, 3 ])
best_fit(net.returns[, 4 ])
best_fit(net.returns[, 5 ])
best_fit(net.returns[, 6 ])
best_fit(net.returns[, 7 ])
best_fit(net.returns[, 8 ])
best_fit(net.returns[, 9 ])
best_fit(net.returns[, 10])
best_fit(net.returns[, 11])
best_fit(net.returns[, 12])
```
Every asset except F, T, and XOM (which all three follow a GED distribution)
follows a t distribution

### Sharpe's Slope
```{r}
SharpeRatio(net.returns, RF = risk.free, FUN="StdDev")

```
Microsoft has the highest sharpe slope, meaning that it has
the greatest reward-to-risk ratio over time.

```{r}
# Convert monthly sample means and sd into annual sample means and sd
yearly.sample.means = m * 12
yearly.sample.means

yearly.sample.std.dev = std.dev * sqrt(12)
yearly.sample.std.dev
# Comment on these numbers
```

```{r,fig.align="center", fig.width = 12, fig.height=10, cache = T}
# Construct scatterplots
ggpairs(net.returns)
ggsave(paste0(IMG_PATH, "net.return.scatter.png"), dpi = 700)

# Comment relationships
```
```{r}
# Covariance matrix
cov.mat %>% as_tibble()

# comment on the direction of linear association

```

## Portfolio Theory
```{r}
# Convert the returns into a matrix for easier computations
R = apply(net.returns, 1, function(x) as.numeric(x))

inv.cov.mat = solve(cov.mat)
ones = matrix(1, dim(inv.cov.mat))

# Compute the MVP
w.mvp = (inv.cov.mat %*% ones) / as.numeric(t(ones) %*% inv.cov.mat %*% ones)
w.mvp

# Mean return
m.mvp = t(w.mvp) %*% m %>% as.numeric()
m.mvp

# Standard deviation
var.mvp = t(w.mvp) %*% cov.mat %*% w.mvp %>% as.numeric()
sd.mvp = sqrt(var.mvp)
sd.mvp

R.mvp = apply(
    R, 2, function(x) {
        t(w.mvp) %*% as.matrix(x, ncol = 1) %>% as.numeric()
    }
) %>% as.numeric()


# VaR
S0 = 1e5
alpha.mvp = 0.05
q.mvp = quantile(R.mvp, probs = c(alpha.mvp))
VaR.mvp = -S0 * q.mvp
VaR.mvp

# Expected Shortfall
ES.mvp = sum((-S0 * R) * (-S0 * R > VaR.mvp)) /  sum(-S0 * R > VaR.mvp)


# Comment on the weights
```
```{r}
yearly.m.mvp = m.mvp * 12
yearly.m.mvp

yearly.sd.mvp = sd.mvp * sqrt(12)
yearly.sd.mvp
```

## Asset Allocation
```{r}
target.expected.return.yearly = 0.06
target.expected.return.monthly = target.expected.return.yearly / 12

```

## Principal Component analysis
```{r}

```

## Risk Management
```{r}

```

## Copulas
```{r}

```

## Conclusion
```{r}

```